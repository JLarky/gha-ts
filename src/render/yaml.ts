import type { Workflow, OnObject, Job } from "../workflow-types";
import {
  isDefaultJob,
  normalizeRunsOn,
  validateWorkflow,
} from "../workflow-types";

export const HEADER =
  "# Do not modify!\n# This file was generated by https://github.com/JLarky/gha-ts\n\n";

function normalizeSchedule(
  schedule: OnObject["schedule"],
): { cron: string }[] | undefined {
  if (!schedule) return undefined;
  if (Array.isArray(schedule)) {
    if (schedule.length === 0) return [];
    const first = schedule[0] as any;
    if (typeof first === "string")
      return (schedule as string[]).map((c) => ({ cron: c }));
    if (typeof first === "object" && first && "cron" in first)
      return schedule as { cron: string }[];
  } else if (typeof schedule === "object" && schedule) {
    const s = schedule as any;
    if (Array.isArray(s.cron))
      return (s.cron as string[]).map((c) => ({ cron: c }));
  }
  return undefined;
}

function normalizeOn(on: Workflow["on"]): any {
  if (typeof on === "string" || Array.isArray(on)) return on;
  const obj: any = { ...on };
  if (obj.schedule !== undefined)
    obj.schedule = normalizeSchedule(obj.schedule);
  return obj;
}

function normalizeJobs(jobs: Record<string, Job>): Record<string, any> {
  const out: Record<string, any> = {};
  for (const [id, job] of Object.entries(jobs)) {
    if (isDefaultJob(job)) {
      out[id] = { ...job, ["runs-on"]: normalizeRunsOn(job["runs-on"]) };
    } else {
      out[id] = job;
    }
  }
  return out;
}

export function toYamlReadyObject(workflow: Workflow): Record<string, unknown> {
  validateWorkflow(workflow);
  const ordered: Record<string, unknown> = {};
  const obj = {
    name: workflow.name,
    on: normalizeOn(workflow.on),
    env: workflow.env,
    concurrency: workflow.concurrency,
    permissions: workflow.permissions,
    jobs: normalizeJobs(workflow.jobs),
  };
  for (const key of [
    "name",
    "on",
    "env",
    "concurrency",
    "permissions",
    "jobs",
  ]) {
    if ((obj as any)[key] !== undefined) ordered[key] = (obj as any)[key];
  }
  return ordered;
}

export type YamlParse = (source: string) => unknown;

/**
 * Parse a YAML string back into a plain JavaScript object.
 * Provide a parser implementation (e.g., Bun.YAML.parse or yaml.parse).
 */
export function parseYamlToObject(
  source: string,
  parse: YamlParse,
): unknown {
  return parse(source);
}

/**
 * Convert a YAML string to a prettified JSON string using the given parser.
 * This is useful for round-trip comparisons that ignore YAML formatting differences.
 */
export function yamlToJsonString(
  source: string,
  parse: YamlParse,
  space: number = 2,
): string {
  const obj = parseYamlToObject(source, parse);
  return JSON.stringify(obj, null, space);
}
